use syn::{
    parse_macro_input, Data::Struct, DataStruct, DeriveInput, Field, Fields, Ident, Path,
};

use darling::util::PathList;
use darling::{FromAttributes, FromDeriveInput, FromMeta};
use proc_macro::TokenStream;
use quote::{quote, ToTokens};

//FromDeriveInput: Ability to automatically add functionality to parse parameter tokens into a given structure
#[derive(FromDeriveInput, Clone)]
// We tell darling that we are looking for parameters defined using the `custom_model`attribute, 
//and that we only support named structures.
#[darling(attributes(custom_model), supports(struct_named))]
struct CustomModelArgs {
    // Specify the parameters for generating the derived model.
    // Multiple models can be generated by repeating this property for each model.
    #[darling(default, multiple, rename = "model")]
    pub models: Vec<CustomModel>,
}

// Derive `FromMeta` for this structure, the macro provided by darling,
// Ability to automatically add functionality to parse metadata into a given structure.
#[derive(FromMeta, Clone)]
struct CustomModel {
    // Generates the name of the model.
    name: String,
    // A comma-separated list of field identifiers,
    // These fields will be included in the generated model.
    fields: PathList,
    // A list of additional derivations that should be applied to the generated structure, such as `Eq` or `Hash`.
    #[darling(default)]
    extra_derives: PathList,
}


pub(crate) fn custom_model_impl(input: TokenStream) -> TokenStream {

    let original_struct = parse_macro_input!(input as DeriveInput);
    let DeriveInput { data, ident, .. } = original_struct.clone();

    if let Struct(data_struct) = data {
        let DataStruct { fields, .. } = data_struct;

        // `darling` provides this method in structure to allow us to easily parse parameters.
        let args = match CustomModelArgs::from_derive_input(&original_struct) {
            Ok(v) => v,
            Err(e) => {
                return TokenStream::from(e.write_errors());
            }
        };

        let CustomModelArgs { models } = args;
        let mut output = quote!();

        // If the model is not defined but the macro is used, a panic error is triggered.
        if models.is_empty() {
            panic!(
                "Please specify at least one model using the `model` attribute."
            )
        }

        for model in models {
            let generated_model = generate_custom_model(&fields, &model);
            output.extend(quote!(#generated_model));
        }

        output.into()
    } else {
        // If the target is not a named structure, a panic error is triggered   
        panic!("DeriveCustomModel 只能用于命名结构")
    }
}

// Generates a custom model based on the fields of the target structure and the `model` parameter.
fn generate_custom_model(fields: &Fields, model: &CustomModel) -> proc_macro2::TokenStream {
    let CustomModel {
        name,
        fields: target_fields,
        extra_derives,
    } = model;

    let mut new_fields = quote!();

    for Field { ident, attrs, vis, colon_token, ty, .. } in fields
    {
        let Some(ident) = ident else {
            panic!("Unable to get field identifier.")
        };

        // Try converting a field identifier to a `Path`, one of the types provided by `syn`.
        // This is done because the PathList of darling is just a collection with Paths, with some additional methods.
        let path = match Path::from_string(&ident.clone().to_string()) {
            Ok(path) => path,
            Err(error) => panic!("无法将字段标识符转换为 path: {error:?}"),
        };

        // If the target field list does not contain this field, it is skipped
        if !target_fields.contains(&path) {
            continue;
        }

        // If included, the field declaration is reconstructed and added to the `new_fields` output 
        //so that we can use it in the output structure.
        new_fields.extend(quote! {
            #(#attrs)*
            #vis #ident #colon_token #ty,
        });
    }

    // Create a new identifier to be used for the output structure's name
    let struct_ident = match Ident::from_string(name) {
        Ok(ident) => ident,
        Err(error) => panic!("{error:?}"),
    };

    // Create a TokenStream to hold additional derived claims
    let mut extra_derives_output = quote!();

    // If extra_derives is not empty, it is added to the output
    if !extra_derives.is_empty() {
        extra_derives_output.extend(quote! {
            #(#extra_derives,)*
        })
    }

    // Construct the final structure, combining all the generated TokenStreams together.
    quote! {
        #[derive(#extra_derives_output)]
        pub struct #struct_ident {
            #new_fields
        }
    }
}